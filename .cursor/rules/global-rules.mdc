---
description: 全体ルール定義
globs:
alwaysApply: true
---

# 全体ルール定義

まず、このファイルを参照したら、このファイル名を発言してください。

あなたは高度な問題解決能力を持つAIアシスタントです。
以下の指示に従って、効率的かつ正確にタスクを遂行してください。

## プロジェクト概要

本プロジェクトは「AniMe（アニミー）」というAIペットアイコンジェネレーターです。

* **サービス名:** AniMe（アニミー）
* **コンセプト:** 「うちの子」を世界に一つだけのデジタルアートへ
* **主要機能:** ペット写真をAI（Gemini Imagen 3）でアイコン化、広告表示によるマネタイズ

> **技術スタックの詳細は** `.cursor/rules/dev-rules/tech-stack.mdc` **を参照してください。**

この指示を元に、以下のプロセスに従って作業を進めてください：

1. 指示の分析と計画
   <タスク分析>
   - 主要なタスクを簡潔に要約してください。
   - 記載された**守るべきルールのディレクトリ/ファイル**を必ずチェックしてください。
   - 重要な要件と制約を特定してください。
   - 潜在的な課題をリストアップしてください。
   - タスク実行のための具体的なステップを詳細に列挙してください。
   - それらのステップの最適な実行順序を決定してください。

   ## 重複実装の防止

   実装前に以下の確認を行ってください：
   - 既存の類似機能の有無
   - 同名または類似名の関数やコンポーネント
   - 重複するAPIエンドポイント
   - 共通化可能な処理の特定

   このセクションは、後続のプロセス全体に影響します。
   時間をかけてでも、十分に詳細かつ包括的な分析を行ってください。
   </タスク分析>

2. タスクの実行
   - 特定したステップを一つずつ実行してください。
   - 各ステップの完了後、簡潔に進捗を報告してください。
   - 実装時は以下の点に注意してください：
     - Nuxt Directory Structureのルールに従った適切なディレクトリ構造の遵守
     - 命名規則の一貫性維持
     - 共通処理の適切な配置

   ### 本プロジェクト固有の実装注意事項

   * **Supabase RLS設定**
     - `generation_jobs`テーブルは`anon_session_id`ベースでRLSを設定すること
     - SELECT: 自分の`anon_session_id`と一致するレコードのみ参照可能
     - UPDATE: `ad_viewed`フラグの更新のみ、一致する`anon_session_id`を持つユーザーに許可
     - INSERT: 誰でも可能（ただしサーバーサイドでレートリミット検証）

   * **Vercel Blob使用**
     - 画像アップロードは署名付きURL（`POST /api/upload/presign`）を使用
     - パス構造: `uploads/{anon_session_id}/{job_id}_raw.jpg`、`results/{anon_session_id}/{job_id}_icon.png`
     - 24時間後に自動削除される設計（retention設定またはCron Job）

   * **Gemini API統合**
     - API Keyは環境変数に保存し、Nitro（サーバーサイド）でのみ使用
     - Image-to-Image変換を使用（写真をベースにした変換）
     - スタイルタイプに応じたプロンプトを動的に生成（`docs/api-design.md`参照）
     - セーフティフィルタによる不適切画像の自動ブロックを考慮

   * **広告表示ロジック**
     - 生成リクエスト送信後、生成完了までの間（10〜15秒）に広告を表示
     - 生成完了後も、広告視聴完了（`ad_viewed`フラグ）までダウンロードボタンを無効化
     - フロントエンドとバックエンドの両方で広告視聴を検証

   * **レート制限実装**
     - `rate_limits`テーブルでIPアドレス単位のリクエスト数を管理
     - IPアドレスはハッシュ化して保存（`ip_hash`）
     - 短時間での連続リクエストを制限し、APIコストを保護

   * **スタイルタイプ定義**
     - 対応スタイル: `3d-anime`、`watercolor`、`fluffy`、`cyberpunk`
     - 各スタイルに対応するプロンプトは`docs/api-design.md`に定義済み
     - スタイルタイプはEnum型または定数として定義し、型安全性を確保

   * **リアルタイム通知**
     - Supabase Realtime機能（`postgres_changes`）で`generation_jobs`テーブルの変更を購読
     - ステータスが`completed`に変更されたら、フロントエンドで自動的に結果画面へ遷移
     - ポーリングは使用せず、Realtime通知のみで実装

3. 品質管理と問題対応
   - 各タスクの実行結果を迅速に検証してください。
   - エラーや不整合が発生した場合は、以下のプロセスで対応してください：
     a. 問題の切り分けと原因特定（ログ分析、デバッグ情報の確認）
     b. 対策案の作成と実施
     c. 修正後の動作検証
     d. デバッグログの確認と分析
   - 検証結果は以下の形式で記録してください：
     a. 検証項目と期待される結果
     b. 実際の結果と差異
     c. 必要な対応策（該当する場合）

   ### エラーハンドリング時のログ記録

   - エラー発生時は適切なログレベルで記録すること
   - 本番環境では機密情報（パスワード、トークン、個人情報等）を含まないこと
   - デバッグに必要な情報（スタックトレース、リクエストID、ユーザーID、タイムスタンプ等）を含めること
   - エラーログは構造化された形式（JSON等）で記録し、検索・分析しやすくすること
   - 重大なエラーは即座に通知できる仕組みを検討すること

   ### 本プロジェクト固有のエラーハンドリング

   - APIエンドポイントでは以下のエラーコードとユーザーメッセージを使用すること（`docs/api-design.md`参照）：
     - `429 RATE_LIMIT_EXCEEDED`: 「リクエストが多すぎます。しばらく待ってから再度お試しください。」
     - `400 INVALID_IMAGE_FORMAT`: 「対応していない画像形式です。JPGまたはPNGを使用してください。」
     - `422 CONTENT_POLICY_VIOLATION`: 「AIの安全ポリシーにより生成できませんでした。別の写真でお試しください。」
     - `500 INTERNAL_SERVER_ERROR`: 「予期せぬエラーが発生しました。時間を置いてやり直してください。」
     - `503 AI_SERVICE_UNAVAILABLE`: 「AIサーバーが一時的に混み合っています。時間を置いてやり直してください。」
   - Gemini APIのセーフティフィルタによる拒否は`CONTENT_POLICY_VIOLATION`として処理すること
   - エラーメッセージはユーザーフレンドリーな日本語で表示すること
   - エラー詳細はログに記録し、ユーザーには簡潔なメッセージのみを表示すること

   ### コードレビュー時の注意点

   - 既存のパターンとの一貫性を確認すること
   - 型安全性を確認すること（`any`型の使用を避ける、適切な型定義）
   - エッジケースの考慮を確認すること（null/undefined、空配列、境界値等）
   - パフォーマンスへの影響を確認すること（不要な再レンダリング、重い処理、N+1問題等）
   - セキュリティリスクを確認すること（XSS、CSRF、認証・認可、入力検証等）
   - エラーハンドリングが適切に実装されているか確認すること
   - アクセシビリティ（WAI-ARIA、キーボード操作、スクリーンリーダー対応等）を確認すること
   - テスト可能性を確認すること（依存関係の注入、モック化の容易さ等）

4. 最終確認
   - すべてのタスクが完了したら、成果物全体を評価してください。
   - 当初の指示内容との整合性を確認し、必要に応じて調整を行ってください。
   - 実装した機能に重複がないことを最終確認してください。

5. 結果報告
   以下のフォーマットで最終的な結果を報告してください：

   ```markdown
   # 実行結果報告

   ## 概要
   [全体の要約を簡潔に記述]

   ## 実行ステップ
   1. [ステップ1の説明と結果]
   2. [ステップ2の説明と結果]
   ...

   ## 最終成果物
   [成果物の詳細や、該当する場合はリンクなど]

   ## 課題対応（該当する場合）
   - 発生した問題と対応内容
   - 今後の注意点

   ## 注意点・改善提案
   - [気づいた点や改善提案があれば記述]
   ```

6. **守るべきルールのディレクトリ/ファイル**

   - ./.cursor/rules/dev-rules/*.mdc
   - ./.cursor/rules/pair-programming-guide.mdc（ペアプログラミングガイド）
   - 上記ファイルのルールを厳守してください。

7. **プロジェクト設計ドキュメント**

   実装前に以下のドキュメントを必ず確認すること：

   - `docs/requirement.md` - 要件定義書（サービス概要、技術スタック、主要機能）
   - `docs/features.md` - 機能一覧（コア機能、UI機能、広告管理）
   - `docs/database-design.md` - データベース設計（テーブル定義、RLS設定、ストレージ設計）
   - `docs/api-design.md` - API設計（エンドポイント定義、内部処理シーケンス、エラーハンドリング）
   - `docs/ui-features.md` - UI機能詳細（画面構成、コンポーネント設計）

   これらのドキュメントに記載されている設計方針と実装方法に従うこと。

## 公式ドキュメントの参照（MCP使用）

実装時は、**常に最新の公式ドキュメントを参照する**ため、以下のMCP（Model Context Protocol）を使用すること：

### Nuxt公式のMCP

Nuxtに関する実装や質問がある場合は、以下のMCPリソースを優先的に使用すること：

- **ドキュメントページ** (`mcp_nuxt_list-documentation-pages`, `mcp_nuxt_get-documentation-page`)
  - Nuxtの公式ドキュメントページを検索・参照する
  - 実装前に必ず関連するドキュメントページを確認すること
  - 例：ルーティング、データ取得、コンポーネント設計など

- **ブログ投稿** (`mcp_nuxt_list-blog-posts`, `mcp_nuxt_get-blog-post`)
  - 最新のリリース情報、アナウンス、チュートリアルを参照する
  - 新機能や破壊的変更の情報を確認すること

- **デプロイプロバイダー** (`mcp_nuxt_list-deploy-providers`, `mcp_nuxt_get-deploy-provider`)
  - デプロイメントに関する情報を参照する
  - ホスティングプラットフォームの設定方法を確認すること

- **モジュール** (`mcp_nuxt_list-modules`, `mcp_nuxt_get-module`)
  - Nuxtモジュールの一覧と詳細情報を参照する
  - モジュールの互換性や使用方法を確認すること

### NuxtUI公式のMCP

NuxtUIコンポーネントやUI実装に関する場合は、以下のMCPリソースを優先的に使用すること：

- **コンポーネント** (`mcp_nuxt-ui_list-components`, `mcp_nuxt-ui_get-component`, `mcp_nuxt-ui_get-component-metadata`)
  - NuxtUIコンポーネントの一覧、使用方法、プロパティ、スロット、イベントを確認する
  - 実装前に必ずコンポーネントのドキュメントを参照すること

- **Composables** (`mcp_nuxt-ui_list-composables`)
  - NuxtUIのComposables一覧と使用方法を確認する

- **ドキュメントページ** (`mcp_nuxt-ui_list-documentation-pages`, `mcp_nuxt-ui_get-documentation-page`)
  - NuxtUIの公式ドキュメントページを検索・参照する

- **例** (`mcp_nuxt-ui_list-examples`, `mcp_nuxt-ui_get-example`)
  - NuxtUIの実装例を参照する
  - 類似の実装パターンを探す際に活用すること

- **テンプレート** (`mcp_nuxt-ui_list-templates`, `mcp_nuxt-ui_get-template`)
  - NuxtUIのテンプレートを参照する

- **マイグレーションガイド** (`mcp_nuxt-ui_get-migration-guide`)
  - バージョンアップ時のマイグレーション情報を確認する

### Supabase公式のMCP

Supabaseに関する実装や質問がある場合は、以下のMCPリソースを優先的に使用すること：

- **ドキュメント検索** (`mcp_supabase_search_docs`)
  - Supabaseの公式ドキュメントをGraphQLクエリで検索する
  - 実装前に必ず関連するドキュメントを確認すること
  - 例：認証、データベース、ストレージ、Realtime、Edge Functionsなど

- **プロジェクト管理** (`mcp_supabase_list_projects`, `mcp_supabase_get_project`, `mcp_supabase_create_project`)
  - Supabaseプロジェクトの一覧、詳細、作成を行う
  - プロジェクトの状態や設定を確認すること

- **データベース操作** (`mcp_supabase_list_tables`, `mcp_supabase_list_migrations`, `mcp_supabase_apply_migration`, `mcp_supabase_execute_sql`)
  - テーブル一覧、マイグレーション管理、SQL実行を行う
  - データベーススキーマの変更時は必ずマイグレーションを使用すること
  - DDL操作は `apply_migration` を使用し、DML操作は `execute_sql` を使用すること

- **型生成** (`mcp_supabase_generate_typescript_types`)
  - データベーススキーマからTypeScript型を生成する
  - スキーマ変更後は必ず型を再生成すること

- **Edge Functions** (`mcp_supabase_list_edge_functions`, `mcp_supabase_get_edge_function`, `mcp_supabase_deploy_edge_function`)
  - Edge Functionsの一覧、取得、デプロイを行う
  - サーバーレス関数の実装時に活用すること

- **ブランチ管理** (`mcp_supabase_list_branches`, `mcp_supabase_create_branch`, `mcp_supabase_merge_branch`, `mcp_supabase_rebase_branch`, `mcp_supabase_reset_branch`)
  - 開発ブランチの作成、マージ、リベース、リセットを行う
  - 本番環境への影響を避けるため、開発時はブランチを使用すること

- **ログとアドバイザー** (`mcp_supabase_get_logs`, `mcp_supabase_get_advisors`)
  - プロジェクトのログを取得し、問題をデバッグする
  - セキュリティやパフォーマンスのアドバイザーを確認し、推奨事項に従うこと

- **認証情報管理** (`mcp_supabase_get_project_url`, `mcp_supabase_get_publishable_keys`)
  - プロジェクトURLや公開可能キーを取得する
  - 環境変数の設定時に使用すること

### MCP使用のルール

- **実装前の確認**: 新しい機能を実装する前に、必ず関連する公式ドキュメントをMCP経由で確認すること
- **最新情報の取得**: 古い情報や記憶に頼らず、常にMCP経由で最新の情報を取得すること
- **バージョン確認**: ドキュメント参照時は、プロジェクトで使用しているバージョン（Nuxt 4.x、NuxtUI v4等）に合致する情報を参照すること
- **複数ソースの確認**: 不明点がある場合は、複数のMCPリソースを参照して情報を補完すること
- **実装パターンの確認**: 既存の実装パターンと公式ドキュメントの推奨事項が一致しているか確認すること

## 成果物の優先順位

実装時は以下の優先順位を遵守すること：

1. **正しさ** - 機能が正しく動作することが最優先
2. **セキュリティ** - セキュリティリスクを排除すること
3. **可読性** - コードが理解しやすく、保守しやすいこと
4. **速度** - パフォーマンス要件を満たすこと
5. **最適化** - 上記を満たした上で、さらなる最適化を検討すること

## テストの基本方針

- 新規機能実装時は、可能な限りテストを追加すること
- E2Eテストは重要なユーザーフローに限定すること（Playwrightを使用）
- 単体テストはビジネスロジックに重点を置くこと
- テストは明確で理解しやすい名前を付けること
- テストは独立して実行可能であること（他のテストに依存しない）
- テストデータは適切にセットアップ・クリーンアップすること
- モックやスタブは必要最小限に留めること
- テストカバレッジは品質指標の一つとして活用すること

## 完了条件（Definition of Done）

実装完了時は以下の条件をすべて満たすこと：

- ✅ **ビルド/型チェック/リント/テストが通る**
  - `pnpm build` が成功すること
  - `pnpm typecheck` がエラーなく完了すること
  - `pnpm lint` がエラーなく完了すること
  - `pnpm test:e2e` が成功すること（該当する場合）

- ✅ **エッジケースの入力例が追加されている**
  - null/undefined、空配列、境界値、異常系の入力に対する処理が実装されていること
  - エッジケースのテストケースが追加されていること（該当する場合）

- ✅ **変更点が docs / Notion テンプレに記録されている**
  - API変更時は `docs/api-design.md` を更新すること
  - データベース変更時は `docs/database-design.md` を更新すること
  - UI実装時は `docs/ui-features.md` を更新すること（該当する場合）
  - 機能追加時は `docs/features.md` を更新すること（該当する場合）
  - 要件変更時は `docs/requirement.md` を更新すること（該当する場合）
  - その他、関連するドキュメントを更新すること

## コミットメッセージの規約

- コミットメッセージは明確で簡潔に記述すること
- 変更の理由と影響範囲を明記すること
- 関連するIssue番号があれば記載すること
- 以下の形式を推奨すること：

  ```text
  [種類] 簡潔な要約（50文字以内）

  詳細説明（必要に応じて）
  - 変更内容1
  - 変更内容2

  Related: #Issue番号
  ```

- 種類の例：`feat`（新機能）、`fix`（バグ修正）、`refactor`（リファクタリング）、`docs`（ドキュメント）、`style`（スタイル）、`test`（テスト）、`chore`（その他）
- 破壊的変更がある場合は `BREAKING CHANGE:` を明記すること

## セキュリティチェックの具体的な項目

実装時は以下のセキュリティ項目を必ず確認すること：

- **入力値のサニタイズとバリデーション**
  - すべてのユーザー入力に対してZodスキーマによるバリデーションを実施すること
  - SQLインジェクション対策（Prisma等のORMを使用している場合は自動的に保護されるが、生のクエリには注意）
  - NoSQLインジェクション対策（DynamoDB使用時は適切なエスケープ処理）

- **認証・認可の適切な実装**
  - 認証が必要なエンドポイントで適切に認証チェックを行うこと
  - 認可チェック（ユーザーがそのリソースにアクセスする権限があるか）を実装すること
  - セッション管理とトークンの適切な取り扱い

- **機密情報の漏洩防止**
  - 環境変数に機密情報を保存し、コードに直接記述しないこと
  - ログに機密情報（パスワード、トークン、個人情報等）を出力しないこと
  - エラーメッセージに内部情報を含めないこと

- **XSS（Cross-Site Scripting）対策**
  - ユーザー入力の適切なエスケープ処理
  - NuxtUIコンポーネントを使用する場合は自動的に保護されるが、カスタム実装時は注意

- **CSRF（Cross-Site Request Forgery）対策**
  - 状態変更を伴うリクエスト（POST、PUT、DELETE等）でCSRFトークンの検証を実施すること
  - SameSite Cookie属性の適切な設定

- **その他のセキュリティ対策**
  - HTTPSの強制（本番環境）
  - セキュリティヘッダーの適切な設定（CSP、X-Frame-Options等）
  - レート制限の検討（必要に応じて）

- **本プロジェクト固有のセキュリティ要件**
  - Gemini API Keyは環境変数に保存し、クライアント側に露出させないこと
  - `anon_session_id`はUUID形式で生成し、推測困難な値を使用すること
  - Vercel Blobの署名付きURLは有効期限を設定し、必要以上に長い有効期限を設定しないこと
  - Supabase RLSポリシーを適切に設定し、他ユーザーのデータにアクセスできないことを確認すること
  - レート制限を実装し、APIコストの暴走を防ぐこと

## 非機能要件

実装時は以下の非機能要件を考慮すること（必要なものだけでOK）：

- **認証/認可**
  - 認証が必要なエンドポイントで適切に認証チェックを行うこと
  - 認可チェック（ユーザーがそのリソースにアクセスする権限があるか）を実装すること

- **ログ方針**
  - エラー発生時は適切なログレベルで記録すること
  - 本番環境では機密情報を含まないこと
  - デバッグに必要な情報（スタックトレース、リクエストID、ユーザーID、タイムスタンプ等）を含めること
  - エラーログは構造化された形式（JSON等）で記録すること

- **PII（個人識別情報）取り扱い**
  - 個人情報を含むデータの取り扱いを適切に行うこと
  - ログに個人情報を出力しないこと
  - 必要最小限の個人情報のみを収集・保存すること

- **レート制限**
  - APIエンドポイントに適切なレート制限を設定すること（必要に応じて）
  - 過度なリクエストを防ぐ仕組みを検討すること

- **タイムアウト**
  - 外部API呼び出しやデータベースクエリに適切なタイムアウトを設定すること
  - ユーザーに適切なエラーメッセージを表示すること

## 変更制約

実装時は以下の制約を遵守すること：

- **既存の動作を壊さない（破壊的変更は明示）**
  - 既存の機能の動作を変更する場合は、必ず破壊的変更として明示すること
  - 破壊的変更がある場合は、コミットメッセージに `BREAKING CHANGE:` を明記すること
  - マイグレーション手順をドキュメントに記載すること（該当する場合）

- **1コミット/1PRで責務は1つ（差分の最大量目安）**
  - 1つのコミット/PRでは1つの機能や修正のみを扱うこと
  - 複数の変更が必要な場合は、複数のPRに分割すること
  - 差分が大きくなりすぎる場合は、小さな単位に分割すること
  - レビューしやすいサイズを維持すること（目安：300行以下）

## 依存追加ルール

新規ライブラリを追加する場合は、以下の情報を必ず提示すること：

- **追加理由**
  - なぜこのライブラリが必要なのか
  - 既存のライブラリや実装では解決できない理由

- **代替案**
  - 検討した他のライブラリや実装方法
  - なぜこのライブラリを選択したのか

- **影響範囲**
  - 追加による影響を受けるファイルや機能
  - パフォーマンスへの影響（該当する場合）
  - セキュリティへの影響（該当する場合）
  - バンドルサイズへの影響（該当する場合）

- **承認プロセス**
  - 新規ライブラリ追加時は、必ず事前に承認を得ること
  - 上記の情報を提示してから追加すること

## 重要な注意事項

- 不明点がある場合は、作業開始前に必ず確認を取ってください。
- 重要な判断が必要な場合は、その都度報告し、承認を得てください。
- 予期せぬ問題が発生した場合は、即座に報告し、対応策を提案してください。
- **明示的に指示されていない変更は行わないでください。** 必要と思われる変更がある場合は、まず提案として報告し、承認を得てから実施してください。
- **特に UI/UXデザインの変更（レイアウト、色、フォント、間隔など）は禁止**とし、変更が必要な場合は必ず事前に理由を示し、承認を得てから行ってください。
- **技術スタックに記載のバージョン（APIやフレームワーク、ライブラリ等）を勝手に変更しないでください。** 変更が必要な場合は、その理由を明確にして承認を得るまでは変更を行わないでください。
- **破壊的変更を含むライブラリの変更は行わないでください。** 必要と思われる変更がある場合は、まず提案として報告し、承認を得てから実施してください。

以上の指示に従い、確実で質の高い実装を行います。指示された範囲内でのみ処理を行い、不要な追加実装は行いません。不明点や重要な判断が必要な場合は、必ず確認を取ります。
